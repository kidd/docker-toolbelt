#+TITLE: Docker toolbelt
#+AUTHOR: Raimon Grau
#+OPTIONS: ':nil *:t -:t ::t <:t H:3 \n:nil ^:nil arch:headline
#+OPTIONS: author:t c:nil creator:comment d:(not "LOGBOOK") date:nil
#+OPTIONS: e:t email:nil f:t inline:t p:nil pri:nil stat:t
#+OPTIONS: tags:t tasks:t tex:t timestamp:t todo:t |:t
#+EXCLUDE_TAGS: noexport
#+KEYWORDS: bash zsh shell
#+LANGUAGE: en
#+SELECT_TAGS: export

#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup

#+OPTIONS: reveal_center:nil timestamp:nil
#+REVEAL_THEME: black

# toc:nil num:nil

* Intro
  Hey! In this doc we're going to learn a few things about docker, and
  about development environments. Stay tuned.

* What do we want?
  The aim of this doc is to learn about docker and docker compose
  through a practical project. This project is a development
  environment generator. Which I'll be building with you as we go.

* When do we want it?
  ASAP

* Why do we want it?
  To have awesome pipelines, development environments, and to learn
  about containers.

* How are we going to do it?
  At first, it's going to be about docker. Then we'll use
  docker-compose, and finally we'll generate docker-compose files
  automatically, like there's no tomorrow.

* What is a container?
  Do you know chroot? ok, imagine you create a chroot and you run a
  something inside it. You are going to run it successfully, and
  that process is only going to have access to that part of the
  filesystem.  But, the process you're running, will it be able
  to see other processes? what would =htop= say? Also, what about
  =ping www.google.com=?

  Containers is how we name cgroups and networking and lxc working
  together to isolate processes from other processes, or group them
  together.

* ETOOMANYFLAGS
  we'll use =docker=. All container systems have too many
  flags. There's a lot of things they can tune, but the amount of
  flags is scary. There's no way around it.

* Lifecycle
  The same as virtual machines, there are several states in which it can be.
  https://medium.com/@BeNitinAgarwal/lifecycle-of-docker-container-d2da9f85959

  The difference with VMS is that usually, you start a VM, and it will
  run some default processes (init, or system32-something, or
  explore.exe). Containers, on the other side, are usually alive only
  while they run the main process you started them with.

  A single container can run multiple processes, but in general, we're
  advised to start containers with a single main process, and when the
  process dies, the container should follow suit.

  There's a hacky way to mimick the VM style more closely, to make it
  easier to build your mental model while learning container
  technology: The trick is to run =tail -f /dev/null= as your main
  process. This is basically a low-consumption infinite loop. We'll
  see more about that later.

* What are containers made of?
  A container needs a few things to run.
  - filesystem. The same as you'd need a .img which is the "saved
    state" that the vm runner will use as a filesystem, container
    running systems need also a fake filesystem to use as its main
    filesystem.

  - networking. Different containers can be running at the same time,
    and you can choose to make them see each other or not. Or you can
    choose to give each one an IP on the same network as the host, or
    not. You can even give them the =--net host= option so that all
    ports opened will live in the same host as the host machine. In
    that case, if you run 1 container that opens port 3000 and another
    that opens 4000, you can reach all services from all containrs, or
    even the host, using =localhost:XXXX=.

  - cpu

* can I run 2 containers on the same filesystem?
  you can run 2 instances of the same Image, making them 2 different
  running containers, and they should be independent from one another.

  Even if you modify the filesystem, one container won't see the
  modification of the other, because they run "copies" of the Image
  filesystem. Nothing is shared unless you specify it.

* patterns
  We'll start seeing different patterns, like small exercises, and
  we'll start adding them up.  It's a bit like =the * schemer= style,
  only worse (because I'm not Dan).

* Build
  =docker build image-directory= will create an image from a list of
  commands in a =Dockerfile=.

  Images are the filesystem of the container. Think a chroot, or think
  the .img or .vdi file you download to run virtualbox on it.

* Dockerfile
  A dockerfile contains the recipe to create the image and leave the
  image in your desired state, ready to be run later on a container.

  It's like a shellscript, with some special commands, but it's an
  imperative script that gets run by =docker build=.

  Q: What runs the dockerfile? in which environment?

* images can extend other images
  Dockerfiles can be divided in 3 parts
  #+begin_src bash
    FROM XXXYYYY     # <- 1 From
    .....            # <- 2 the rest
    .....
    .....
    .....
    .....
    CMD/ENTRYPOINT/RUN #<- run command
  #+end_src

  You usually start from an image that already has some contents in
  its filesystem. That's why usually Dockerfiles start with the name
  of a distro =FROM ubuntu:20.04=.  If you'd like a completely empty
  filesystem to start from, there's an images called =scratch=, that
  looks like a recently formatted filesystem.

* can I only "inherit" from an official image?
  You can inherit from any image. Images can be in a container
  registry (usually on the internet), or locally, where you have a
  local collection of already downloaded images, ready to be used.

  Also, when you're using =docker build=, you are creating a new
  image.

* Examples?
  #+begin_src bash
    echo <<EOF
      FROM ubuntu:20.04
    EOF >Dockerfile
    docker build .

    ....
    Successfully build 7e0aa2e69a15
  #+end_src
  At this point, 7e0aa2e69a15 is functionally exact as the
  ubuntu:20.04. it's like subclassing a class without changing any
  method.

* How do we know it?
  #+begin_src bash
    diff <(docker inspect 7e0aa2e69a15) <(docker inspect ubuntu:20.04)
  #+end_src

* Let's play with docker inspect
  #+begin_src bash
    echo <<EOF
      FROM ubuntu:20.04
      CMD ["tail -f /dev/null"]
    EOF >Dockerfile
    docker build .

    ....
    Successfully build aabbccdd
  #+end_src
  Now, let's diff them:
  #+begin_src bash
    diff <(docker inspect aabbccdd) <(docker inspect ubuntu:20.04)
  #+end_src

  Now we see the differences, and they mostly make sense. I guess you
  now can be confident with =inspect=. Everything should make sense.

* Where/how are those images stored?
  Instead of having a .iso, .img, or .vdk, images are stored as a
  directory with a bunch of data and metadata.

* Dockerfiles are like
  #+begin_src bash
    git clone ubuntu:20.04 --depth=1
    cmd1
    git add -A; git commit -m 'step1'
    cmd2
    git add -A; git commit -m 'step2'
    ....
  #+end_src

  If you imagine 2 dockerfiles that are equal except in the last line,
  all but last lines are producing the same images. Docker is smart
  enough to share them, so the "blobs" (in git parlance) are unique
  (to keep the analogy working, you've got to obviate the fact that
  git would create different commits because they happen on different
  dates)

* Running a container
  Once we have the image filesystem, we're ready to run it. When we
  run a process inside that image, jailed in a docker network
  (described in the =docker run= command), we are "starting" the
  container.

  In that moment, you can think of a last ephemeral commit in that
  chain of commits. We could be modifying files there, and we would
  see them, but when we stop and kill the container, that layer would
  disappear.

* Minimal flags
  - =docker run --rm -ti image command= . Those flags the basic
    combination. =--rm= tells it to clean after itself, removing
    whatever it created to make a container from =image=. =-ti= binds
    an interactive terminal, so we can communicate with it. You want
    that when running things locally 90% of the time.

  - =docker run --net=host= . This flattens all networking of that
    container to use the same ip as the host, so everything lives in
    the same machine, and can get to the other via
    =localhost=. Problem with it is that ports may collide. just be
    aware it's a shortcut and you'll probably want to fix it at some
    point.

  - =docker run -v $PWD:/my-dir= mounts a directory from host to
    container.

* testing images and containers
  =docker run --rm -ti ubuntu:20.04 bash=.  This will open a bash
  starting from an ubuntu:20.04 image.

  In another terminal, run =docker run --rm -ti ubuntu:20.04 bash=
  again.

  You can see that both containers are running independently (files
  created in one are not seen in the other one).

  And each one of them thinks it's unique. try to run =top= in each
  one of them. They shouldn't see each other.

  But still, if you run =docker ps= from the host, you can see both
  containers run from the same image.

* Commit
  I said that a running container has that ephemeral last layer, where
  your modifications happen, and they survive a =stop/start=, but they
  don't survive a kill or rm.

  But there's a way to make the current state permanent, and
  effectively create an image, from where new containers can be
  spawned or new Dockerfiles can start FROM.

  #+begin_src bash
    docker run -ti ubuntu:20.04 bash
    # inside the container
    echo 'hi' >/tmp/foo
  #+end_src

  And in the host
  #+begin_src bash
    $ docker ps
    CONTAINER ID        IMAGE                       COMMAND                  CREATED             STATUS              PORTS                                            NAMES
    c6e13a79c7b3        ubuntu                      "bash"                   15 seconds ago      Up 14 seconds                                                        determined_wu
    $ docker commit c6e13a79c7b3
    sha256:d6581aae94a58d9be27b6fecf576630fead7a05b003be12796152110d7f0b010
    $ docker run --rm -ti d6581aae94a58d9be27b6fecf576630fead7a05b cat /tmp/foo
    hi
  #+end_src

See? we created a new image, and we started a container from it

* Env vars
  Build time =.env=, runtime =-e= .

* If I am a program running on a container, what do I see?
  try it. =docker run -ti --rm ubuntu top=.

* Can a container run more than one process?
  Yes. Let's try something
  #+begin_src bash
    docker run --rm -ti ubuntu bash
    # inside the container's shell
    top
  #+end_src
  There you see 2 processes, bash and top.

* Using cat from ubuntu container
  #+begin_src bash
    docker run --rm ubuntu cat /etc/lsb-release
  #+end_src

* mount a file and cat it from inside
  #+begin_src bash
    docker run --rm -v /etc/lsb-release:/etc/lsb-release ubuntu cat /etc/lsb-release
  #+end_src

* Docker as a tool to help you hack on development
- https://fly.io/blog/docker-without-docker/
    - https://gist.github.com/tqbf/10006fae0b81d7c7c93513890ff0cf08
- https://vsupalov.com/rebuilding-docker-image-development/
** network
- http://flaviotoffalini.info/posts/2019/07/docker-network/
- https://www.cb-net.co.uk/devops/docker-container-network-isolation/
- https://iximiuz.com/en/posts/container-networking-is-simple/
* dev
  - https://earthly.dev/
