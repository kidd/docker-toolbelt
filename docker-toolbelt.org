#+TITLE: Docker toolbelt
#+AUTHOR: Raimon Grau
#+OPTIONS: ':nil *:t -:t ::t <:t H:3 \n:nil ^:nil arch:headline
#+OPTIONS: author:t c:nil creator:comment d:(not "LOGBOOK") date:nil
#+OPTIONS: e:t email:nil f:t inline:t p:nil pri:nil stat:t
#+OPTIONS: tags:t tasks:t tex:t timestamp:t todo:t |:t
#+EXCLUDE_TAGS: noexport
#+KEYWORDS: bash zsh shell
#+LANGUAGE: en
#+SELECT_TAGS: export

#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup

#+OPTIONS: reveal_center:nil timestamp:nil
#+REVEAL_THEME: black

# toc:nil num:nil

* Intro
  Hey! In this doc we're going to learn a few things about docker, and
  about development environments. Stay tuned.

* What do we want?
  The aim of this doc is to learn about docker and docker compose
  through a practical project. This project is a development
  environment generator. Which I'll be building with you as we go.

* When do we want it?
  ASAP

* Why do we want it?
  To have awesome pipelines, development environments, and to learn
  about containers.

* How are we going to do it?
  At first, it's going to be about docker. Then we'll use
  docker-compose, and finally we'll generate docker-compose files
  automatically, like there's no tomorrow.

* What is a container?
  Do you know chroot? ok, imagine you create a chroot and you run a
  something inside it. You are going to run it successfully, and
  that process is only going to have access to that part of the
  filesystem.  But, the process you're running, will it be able
  to see other processes? what would =htop= say? Also, what about
  =ping www.google.com=?

  Containers is how we name cgroups and networking and lxc working
  together.

* ETOOMANYFLAGS
  we'll use =docker=. All container systems have too many
  flags. There's a lot of things they can tune, but the amount of
  flags is scary. There's no way around it.

* Lifecycle
  The same as virtual machines, there are several states in which it can be.
  https://medium.com/@BeNitinAgarwal/lifecycle-of-docker-container-d2da9f85959

* areas
  - filesystem
  - networking
  - cpu

* patterns
  We'll start seeing different patterns, like small exercises, and
  we'll start adding them up.

* Build
  =docker build image-directory= will create an image from a list of
  commands in a =Dockerfile=.

  Images are the filesystem of the container. Think a chroot, or think
  the .img or .vdi file you download to run virtualbox on it.

* Dockerfile
  A dockerfile contains the recipe to create the image, ready to be
  run later on a container.

  It's like a shellscript, with some special commands, but it's an
  imperative script that gets run.

  Q: What runs the dockerfile? in which environment?

* images can extend other images
  Dockerfiles can be divided in 3 parts
  #+begin_src bash
    FROM XXXYYYY     # <- 1 From
    .....            # <- 2 the rest
    .....
    .....
    .....
    .....
    CMD/ENTRYPOINT/RUN #<- run command
  #+end_src

  You usually start from an image that already has some contents in
  its filesystem. That's why usually Dockerfiles start with the name
  of a distro =FROM ubuntu:20.04=.

* Dockerfiles are like
  #+begin_src bash
    git clone ubuntu:20.04 --depth=1
    cmd1
    git add -A; git commit -m 'step1'
    cmd2
    git add -A; git commit -m 'step2'
    ....
  #+end_src

  If you imagine 2 dockerfiles that are equal except in the last line,
  all but last lines are producing the same images. Docker is smart
  enough to share them, so the "blobs" (in git parlance) are unique
  (to keep the analogy working, you've got to obviate the fact that
  git would create different commits because they happen on different
  dates)

* Running a container
  Once we have the image filesystem, we're ready to run it. When we
  run a process inside that image, jailed in a docker network
  (described in the =docker run= command), we are "starting" the
  container.

  In that moment, you can think of a last ephemeral commit in that
  chain of commits. We could be modifying files there, and we would
  see them, but when we stop and kill the container, that layer would
  disappear.

* Minimal flags
  - =docker run --rm -ti image command= . Those flags the basic
    combination. =--rm= tells it to clean after itself, removing
    whatever it created to make a container from =image=. =-ti= binds
    an interactive terminal, so we can communicate with it. You want
    that when running things locally 90% of the time.

  - =docker run --net=host= . This flattens all networking of that
    container to use the same ip as the host, so everything lives in
    the same machine, and can get to the other via
    =localhost=. Problem with it is that ports may collide. just be
    aware it's a shortcut and you'll probably want to fix it at some
    point.

  - =docker run -v $PWD:/my-dir= mounts a directory from host to
    container.

* testing images and containers
  =docker run --rm -ti ubuntu:20.04 bash=.  This will open a bash
  starting from an ubuntu:20.04 image.

  In another terminal, run =docker run --rm -ti ubuntu:20.04 bash=
  again.

  You can see that both containers are running independently (files
  created in one are not seen in the other one).

  And each one of them thinks it's unique. try to run =top= in each
  one of them. They shouldn't see each other.

  But still, if you run =docker ps= from the host, you can see both
  containers run from the same image.

* Commit
  I said that a running container has that ephemeral last layer, where
  your modifications happen, and they survive a =stop/start=, but they
  don't survive a kill or rm.

  But there's a way to make the current state permanent, and
  effectively create an image, from where new containers can be
  spawned or new Dockerfiles can start FROM.

  #+begin_src bash
    docker run -ti ubuntu:20.04 bash
    # inside the container
    echo 'hi' >/tmp/foo
  #+end_src

  And in the host
  #+begin_src bash
    $ docker ps                                                                                                  [21-05-09 1:18]
    CONTAINER ID        IMAGE                       COMMAND                  CREATED             STATUS              PORTS                                            NAMES
    c6e13a79c7b3        ubuntu                      "bash"                   15 seconds ago      Up 14 seconds                                                        determined_wu
    $ docker commit c6e13a79c7b3                                                                           0s  - [21-05-09 1:18]
    sha256:d6581aae94a58d9be27b6fecf576630fead7a05b003be12796152110d7f0b010
    $ docker run --rm -ti d6581aae94a58d9be27b6fecf576630fead7a05b cat /tmp/foo
    hi
  #+end_src

See? we created a new image, and we started a container from it

* Env vars
  Build time =.env=, runtime =-e= .

* If I am a program running on a container, what do I see?
  try it. =docker run -ti --rm ubuntu top=.

* Can a container run more than one process?
  Yes. Let's try something
  #+begin_src bash
    docker run --rm -ti ubuntu bash
    # inside the container's shell
    top
  #+end_src
  There you see 2 processes, bash and top.

* Using cat from ubuntu container
  #+begin_src bash
    docker run --rm ubuntu cat /etc/lsb-release
  #+end_src

* mount a file and cat it from inside
  #+begin_src bash
    docker run --rm -v /etc/lsb-release:/etc/lsb-release ubuntu cat /etc/lsb-release
  #+end_src

* Docker as a tool to help you hack on development
- https://fly.io/blog/docker-without-docker/
- https://vsupalov.com/rebuilding-docker-image-development/
** network
- http://flaviotoffalini.info/posts/2019/07/docker-network/
- https://www.cb-net.co.uk/devops/docker-container-network-isolation/
- https://iximiuz.com/en/posts/container-networking-is-simple/
* dev
  - https://earthly.dev/
