<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Docker toolbelt</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Raimon Grau" />
<meta name="keywords" content="bash zsh shell" />
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Docker toolbelt</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgc0cda01">1. Intro</a></li>
<li><a href="#org2c826a8">2. What do we want?</a></li>
<li><a href="#org286476e">3. When do we want it?</a></li>
<li><a href="#org1df78b5">4. Why do we want it?</a></li>
<li><a href="#org2a15564">5. How are we going to do it?</a></li>
<li><a href="#org752656c">6. What is a container?</a></li>
<li><a href="#org39cb6d6">7. ETOOMANYFLAGS</a></li>
<li><a href="#orgd885ffd">8. What are containers made of?</a></li>
<li><a href="#org6682e68">9. can I run 2 containers on the same filesystem?</a></li>
<li><a href="#org954b0d0">10. patterns</a></li>
<li><a href="#org38c4498">11. Build</a></li>
<li><a href="#orgdcfa4e3">12. Dockerfile</a></li>
<li><a href="#org988750b">13. images can extend other images</a></li>
<li><a href="#org865f75e">14. can I only "inherit" from an official image?</a></li>
<li><a href="#orge2a8300">15. Examples?</a></li>
<li><a href="#org19179df">16. How do we know it?</a></li>
<li><a href="#org74969c8">17. Let's play with docker inspect</a></li>
<li><a href="#orgccbd7ca">18. Where/how are those images stored?</a></li>
<li><a href="#orgf45ecaa">19. Dockerfiles are like</a></li>
<li><a href="#orga98eb79">20. Running a container</a></li>
<li><a href="#orgea4eb0a">21. Minimal flags</a></li>
<li><a href="#orgd86b4e8">22. testing images and containers</a></li>
<li><a href="#orga40ed4e">23. Running multiple commands</a></li>
<li><a href="#org26a9960">24. Commit</a></li>
<li><a href="#org5a5cac9">25. Env vars</a></li>
<li><a href="#org8e23876">26. If I am a program running on a container, what do I see?</a>
<ul>
<li><a href="#orge9c1e5b">26.1. Processes</a></li>
<li><a href="#org57a83c4">26.2. Network</a></li>
<li><a href="#orgaec6fa8">26.3. filesystem</a></li>
</ul>
</li>
<li><a href="#org1d0deb9">27. Can a container run more than one process?</a></li>
<li><a href="#org5f3bed6">28. Using cat from ubuntu container</a></li>
<li><a href="#org94f982e">29. mount a file and cat it from inside</a></li>
<li><a href="#org6bfabd7">30. Playing with scratch image</a></li>
<li><a href="#org9e42379">31. Entrypoint</a></li>
<li><a href="#org587e44e">32. Network</a></li>
<li><a href="#org2806fc4">33. Deploy SPA Frontend and Backend</a></li>
<li><a href="#org70a17f3">34. container names in a docker-compose</a></li>
<li><a href="#org0d93cbc">35. Traefik and whole whole shebang</a></li>
<li><a href="#orgb05a1f8">36. can I join?</a></li>
<li><a href="#orga5e62e7">37. http_proxy, dns, and networks</a></li>
<li><a href="#orgd5e060b">38. Dok</a></li>
<li><a href="#org35fff32">39. gojira</a></li>
<li><a href="#org4969abb">40. ryu</a></li>
<li><a href="#orgdf7739d">41. mba</a></li>
<li><a href="#org0733561">42. hma</a>
<ul>
<li><a href="#org834e5fe">42.1. Mount every container's <i>root to ~</i>.hma/.hma-home/</a></li>
<li><a href="#org850a535">42.2. Customize the main app's service</a></li>
<li><a href="#orgc5cce7c">42.3. Dockerfile</a></li>
<li><a href="#org337c842">42.4. Development</a></li>
<li><a href="#org6a507de">42.5. Code</a></li>
</ul>
</li>
<li><a href="#org0d6176d">43. Docker as a tool to help you hack on development</a>
<ul>
<li><a href="#orgac76fc8">43.1. network</a></li>
</ul>
</li>
<li><a href="#orgbf7de52">44. dev</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgc0cda01" class="outline-2">
<h2 id="orgc0cda01"><span class="section-number-2">1</span> Intro</h2>
<div class="outline-text-2" id="text-1">
<p>
Hey! In this doc we're going to learn a few things about docker, and
about development environments. Stay tuned.
</p>
</div>
</div>

<div id="outline-container-org2c826a8" class="outline-2">
<h2 id="org2c826a8"><span class="section-number-2">2</span> What do we want?</h2>
<div class="outline-text-2" id="text-2">
<p>
The aim of this doc is to learn about docker and docker compose
through a practical project. This project is a development
environment generator. Which I'll be building with you as we go.
</p>
</div>
</div>

<div id="outline-container-org286476e" class="outline-2">
<h2 id="org286476e"><span class="section-number-2">3</span> When do we want it?</h2>
<div class="outline-text-2" id="text-3">
<p>
ASAP
</p>
</div>
</div>

<div id="outline-container-org1df78b5" class="outline-2">
<h2 id="org1df78b5"><span class="section-number-2">4</span> Why do we want it?</h2>
<div class="outline-text-2" id="text-4">
<p>
To have awesome pipelines, development environments, and to learn
about containers.
</p>
</div>
</div>

<div id="outline-container-org2a15564" class="outline-2">
<h2 id="org2a15564"><span class="section-number-2">5</span> How are we going to do it?</h2>
<div class="outline-text-2" id="text-5">
<p>
At first, it's going to be about docker. Then we'll use
docker-compose, and finally we'll generate docker-compose files
automatically, like there's no tomorrow.
</p>
</div>
</div>

<div id="outline-container-org752656c" class="outline-2">
<h2 id="org752656c"><span class="section-number-2">6</span> What is a container?</h2>
<div class="outline-text-2" id="text-6">
<p>
Do you know chroot? ok, imagine you create a chroot and you run a
something inside it. You are going to run it successfully, and
that process is only going to have access to that part of the
filesystem.  But, the process you're running, will it be able
to see other processes? what would <code>htop</code> say? Also, what about
<code>ping www.google.com</code>?
</p>

<p>
Containers is how we name cgroups and networking and lxc working
together to isolate processes from other processes, or group them
together.
</p>
</div>
</div>

<div id="outline-container-org39cb6d6" class="outline-2">
<h2 id="org39cb6d6"><span class="section-number-2">7</span> ETOOMANYFLAGS</h2>
<div class="outline-text-2" id="text-7">
<p>
we'll use <code>docker</code>. All container systems have too many
flags. There's a lot of things they can tune, but the amount of
flags is scary. There's no way around it.
</p>
</div>
</div>

<div id="outline-container-orgd885ffd" class="outline-2">
<h2 id="orgd885ffd"><span class="section-number-2">8</span> What are containers made of?</h2>
<div class="outline-text-2" id="text-8">
<p>
A container needs a few things to run.
</p>
<ul class="org-ul">
<li>filesystem. The same as you'd need an <code>.img</code> which is the "saved
state" that the vm runner will use as a filesystem, container
running systems need also a fake filesystem to use as its main
filesystem.</li>

<li>networking. Different containers can be running at the same time,
and you can choose to make them see each other or not. Or you can
choose to give each one an IP on the same network as the host, or
not. You can even give them the <code>--net host</code> option so that all
ports opened will live in the same host as the host machine. In
that case, if you run 1 container that opens port 3000 and another
that opens 4000, you can reach all services from all containrs, or
even the host, using <code>localhost:XXXX</code>.</li>

<li>cpu</li>
</ul>
</div>
</div>

<div id="outline-container-org6682e68" class="outline-2">
<h2 id="org6682e68"><span class="section-number-2">9</span> can I run 2 containers on the same filesystem?</h2>
<div class="outline-text-2" id="text-9">
<p>
you can run 2 containers from the same Image, making them 2
different running containers, and they should be independent from
one another. They will have access to the same filesystem (except
for the last layer, which is the RW one, which is independent for
each container).
</p>

<p>
If you modify the filesystem, one container won't see the
modification of the other, because they run "copies" of the Image
filesystem. The shared layers are read only, so each container feels
it runs in complete isolation (unless you mount parts of the
filesystems from one to the other)
</p>
</div>
</div>

<div id="outline-container-org954b0d0" class="outline-2">
<h2 id="org954b0d0"><span class="section-number-2">10</span> patterns</h2>
<div class="outline-text-2" id="text-10">
<p>
We'll start seeing different patterns, like small exercises, and
we'll start adding them up.  It's a bit like <code>the * schemer</code> style,
only worse (because I'm not Dan).
</p>
</div>
</div>

<div id="outline-container-org38c4498" class="outline-2">
<h2 id="org38c4498"><span class="section-number-2">11</span> Build</h2>
<div class="outline-text-2" id="text-11">
<p>
<code>docker build image-directory</code> will create an image from a list of
commands in a <code>Dockerfile</code>.
</p>

<p>
Images are the filesystem of the container. Think a chroot, or think
the .img or .vdi file you download to run virtualbox on it.
</p>
</div>
</div>

<div id="outline-container-orgdcfa4e3" class="outline-2">
<h2 id="orgdcfa4e3"><span class="section-number-2">12</span> Dockerfile</h2>
<div class="outline-text-2" id="text-12">
<p>
A dockerfile contains the recipe to create the image and leave the
image in your desired state, ready to be run later on a container.
</p>

<p>
It's like a shellscript, with some special commands, but it's an
imperative script that gets run by <code>docker build</code>. Its goal is to
leave a filesystem in the state that it can run your app when
<code>docker run img</code>.
</p>

<p>
Q: What runs the dockerfile? in which environment?
</p>
</div>
</div>

<div id="outline-container-org988750b" class="outline-2">
<h2 id="org988750b"><span class="section-number-2">13</span> images can extend other images</h2>
<div class="outline-text-2" id="text-13">
<p>
Dockerfiles can be divided in 3 parts
</p>
<div class="org-src-container">
<pre class="src src-bash">FROM XXXYYYY     <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">&lt;- 1 From</span>
.....            <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">&lt;- 2 Build more things</span>
.....
.....
.....
.....
CMD/ENTRYPOINT/RUN <span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">&lt;- run command</span>
</pre>
</div>

<p>
You usually start from an image that already has some contents in
its filesystem. That's why usually Dockerfiles start with the name
of a distro <code>FROM ubuntu:20.04</code>.  If you'd like a completely empty
filesystem to start from, there's an images called <code>scratch</code>, that
looks like a recently formatted filesystem.
</p>

<p>
CMD/ENTRYPOINT/RUN part is used to give a default entrypoint or
command to run when we run a new container from that image. The
command can be overriden, but it's nice to have good defaults.
</p>
</div>
</div>

<div id="outline-container-org865f75e" class="outline-2">
<h2 id="org865f75e"><span class="section-number-2">14</span> can I only "inherit" from an official image?</h2>
<div class="outline-text-2" id="text-14">
<p>
You can inherit from any image. Images can be in a container
registry (usually on the internet), or locally, where you have a
local collection of already downloaded images, ready to be used.
</p>

<p>
Also, when you're using <code>docker build</code>, you are creating a new
image.
</p>
</div>
</div>

<div id="outline-container-orge2a8300" class="outline-2">
<h2 id="orge2a8300"><span class="section-number-2">15</span> Examples?</h2>
<div class="outline-text-2" id="text-15">
<div class="org-src-container">
<pre class="src src-bash"><span style="font-weight: bold;">echo</span> &lt;&lt;EOF
<span style="font-weight: bold;">  FROM ubuntu:20.04</span>
<span style="font-weight: bold;">EOF &gt;Dockerfile</span>
<span style="font-weight: bold;">docker build .</span>

<span style="font-weight: bold;">....</span>
<span style="font-weight: bold;">Successfully build 7e0aa2e69a15</span>
</pre>
</div>
<p>
At this point, 7e0aa2e69a15 is the exact filestystem as the
ubuntu:20.04. it's like subclassing a class without changing any
method.
</p>
</div>
</div>

<div id="outline-container-org19179df" class="outline-2">
<h2 id="org19179df"><span class="section-number-2">16</span> How do we know it?</h2>
<div class="outline-text-2" id="text-16">
<div class="org-src-container">
<pre class="src src-bash">diff &lt;(docker inspect 7e0aa2e69a15) &lt;(docker inspect ubuntu:20.04)
</pre>
</div>
</div>
</div>

<div id="outline-container-org74969c8" class="outline-2">
<h2 id="org74969c8"><span class="section-number-2">17</span> Let's play with docker inspect</h2>
<div class="outline-text-2" id="text-17">
<p>
Let's try to change the default command that our container will run.
</p>
<div class="org-src-container">
<pre class="src src-bash"><span style="font-weight: bold;">echo</span> &lt;&lt;EOF
<span style="font-weight: bold;">  FROM ubuntu:20.04</span>
<span style="font-weight: bold;">  CMD ["tail -f /dev/null"]</span>
<span style="font-weight: bold;">EOF &gt;Dockerfile</span>
<span style="font-weight: bold;">docker build .</span>

<span style="font-weight: bold;">....</span>
<span style="font-weight: bold;">Successfully build aabbccdd</span>
</pre>
</div>
<p>
Now, let's diff them:
</p>
<div class="org-src-container">
<pre class="src src-bash">diff &lt;(docker inspect aabbccdd) &lt;(docker inspect ubuntu:20.04)
</pre>
</div>

<p>
Now we see the differences, and they mostly make sense. I guess you
now can be confident with <code>inspect</code>. Everything should make sense.
</p>
</div>
</div>

<div id="outline-container-orgccbd7ca" class="outline-2">
<h2 id="orgccbd7ca"><span class="section-number-2">18</span> Where/how are those images stored?</h2>
<div class="outline-text-2" id="text-18">
<p>
Instead of having a .iso, .img, or .vdk, images are stored as a
directory with a bunch of data and metadata.
</p>
</div>
</div>

<div id="outline-container-orgf45ecaa" class="outline-2">
<h2 id="orgf45ecaa"><span class="section-number-2">19</span> Dockerfiles are like</h2>
<div class="outline-text-2" id="text-19">
<div class="org-src-container">
<pre class="src src-bash">git clone ubuntu:20.04 --depth=1
cmd1
git add -A; git commit -m <span style="font-style: italic;">'step1'</span>
cmd2
git add -A; git commit -m <span style="font-style: italic;">'step2'</span>
....
</pre>
</div>

<p>
If you imagine 2 dockerfiles that are equal except in the last line,
all but last lines are producing the same images. Docker is smart
enough to share them, so the "blobs" (in git parlance) are unique
(to keep the analogy working, you've got to obviate the fact that
git would create different commits because they happen on different
dates)
</p>
</div>
</div>

<div id="outline-container-orga98eb79" class="outline-2">
<h2 id="orga98eb79"><span class="section-number-2">20</span> Running a container</h2>
<div class="outline-text-2" id="text-20">
<p>
Once we have the image filesystem, we're ready to bring its contents
to life.  When we run a process inside that image, jailed in a
docker network (described in the <code>docker run</code> command), we are
"starting" the container.
</p>

<p>
In that moment, you can think of a last ephemeral commit in that
chain of commits being added.  We could be modifying files there,
and we would see them, but when we stop and kill the container, that
layer would disappear.
</p>
</div>
</div>

<div id="outline-container-orgea4eb0a" class="outline-2">
<h2 id="orgea4eb0a"><span class="section-number-2">21</span> Minimal flags</h2>
<div class="outline-text-2" id="text-21">
<ul class="org-ul">
<li><code>docker run --rm -ti image command</code> . Those flags the basic
combination. <code>--rm</code> tells it to clean after itself, removing
whatever it created to make a container from <code>image</code>. <code>-ti</code> binds
an interactive terminal, so we can communicate with it. You want
that when running things locally 90% of the time.</li>

<li><code>docker run --net=host</code> . This flattens all networking of that
container to use the same ip as the host, so everything lives in
the same machine, and can get to the other via
<code>localhost</code>. Problem with it is that ports may collide. just be
aware it's a shortcut and you'll probably want to fix it at some
point.</li>

<li><code>docker run -v $PWD:/my-dir</code> mounts a directory from host to
container.</li>
</ul>
</div>
</div>

<div id="outline-container-orgd86b4e8" class="outline-2">
<h2 id="orgd86b4e8"><span class="section-number-2">22</span> testing images and containers</h2>
<div class="outline-text-2" id="text-22">
<p>
<code>docker run --rm -ti ubuntu:20.04 bash</code>.  This will open a bash
starting from an ubuntu:20.04 image.
</p>

<p>
In another terminal, run <code>docker run --rm -ti ubuntu:20.04 bash</code>
again.
</p>

<p>
You can see that both containers are running independently (files
created in one are not seen in the other one).
</p>

<p>
And each one of them thinks it's unique. try to run <code>top</code> in each
one of them. They shouldn't see each other.
</p>

<p>
But still, if you run <code>docker ps</code> from the host, you can see both
containers run from the same image.
</p>
</div>
</div>

<div id="outline-container-orga40ed4e" class="outline-2">
<h2 id="orga40ed4e"><span class="section-number-2">23</span> Running multiple commands</h2>
<div class="outline-text-2" id="text-23">
<p>
<code>docker run --rm -ti ubuntu "apt update | apt install foo"</code> doesn't
work, but if you want to run several commands at the same time from
the "run" command, To test things out from a script, you can use
</p>

<div class="org-src-container">
<pre class="src src-bash">docker run --rm -ti ubuntu bash -ci <span style="font-style: italic;">"apt update &amp;&amp; apt install net-tools"</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org26a9960" class="outline-2">
<h2 id="org26a9960"><span class="section-number-2">24</span> Commit</h2>
<div class="outline-text-2" id="text-24">
<p>
I said that a running container has that ephemeral last layer, where
your modifications happen, and they survive a <code>stop/start</code>, but they
don't survive a kill or rm.
</p>

<p>
But there's a way to make the current state permanent, and
effectively create an image, from where new containers can be
spawned or new Dockerfiles can start FROM.
</p>

<div class="org-src-container">
<pre class="src src-bash">docker run -ti ubuntu:20.04 bash
<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">inside the container</span>
<span style="font-weight: bold;">echo</span> <span style="font-style: italic;">'hi'</span> &gt;/tmp/foo
</pre>
</div>

<p>
And in the host
</p>
<div class="org-src-container">
<pre class="src src-bash">$ docker ps
CONTAINER ID        IMAGE                       COMMAND                  CREATED             STATUS              PORTS                                            NAMES
c6e13a79c7b3        ubuntu                      <span style="font-style: italic;">"bash"</span>                   15 seconds ago      Up 14 seconds                                                        determined_wu
$ docker commit c6e13a79c7b3
sha256:d6581aae94a58d9be27b6fecf576630fead7a05b003be12796152110d7f0b010
$ docker run --rm -ti d6581aae94a58d9be27b6fecf576630fead7a05b cat /tmp/foo
hi
</pre>
</div>

<p>
See? we created a new image, and we started a container from it
</p>
</div>
</div>

<div id="outline-container-org5a5cac9" class="outline-2">
<h2 id="org5a5cac9"><span class="section-number-2">25</span> Env vars</h2>
<div class="outline-text-2" id="text-25">
<p>
Build time <code>.env</code>, runtime <code>-e</code> .
</p>

<p>
Env vars that appear in the compose can be overriden, others no
(imagine if we could be able to mount and update LD_PRELOAD, not
good).
</p>
<ul class="org-ul">
<li><a href="https://docs.docker.com/compose/environment-variables/">https://docs.docker.com/compose/environment-variables/</a></li>
<li><a href="https://stackoverflow.com/questions/43106459/environment-variable-assignment-in-docker-compose-colon-way">https://stackoverflow.com/questions/43106459/environment-variable-assignment-in-docker-compose-colon-way</a></li>
<li><a href="https://docs.docker.com/compose/compose-file/compose-file-v3/">https://docs.docker.com/compose/compose-file/compose-file-v3/</a></li>
</ul>

<p>
In projects/empty-dict-value there's an example of different ways to interact with them:
</p>
<ul class="org-ul">
<li>docker-compose run -e foo=123 mything0 ; docker eec -ti &#x2026; bash ; echo $foo</li>
</ul>
</div>
</div>
<div id="outline-container-org8e23876" class="outline-2">
<h2 id="org8e23876"><span class="section-number-2">26</span> If I am a program running on a container, what do I see?</h2>
<div class="outline-text-2" id="text-26">
<p>
try it: We said there are mostly 3 things that get isolated: network, filesystem and processes.
</p>
</div>

<div id="outline-container-orge9c1e5b" class="outline-3">
<h3 id="orge9c1e5b"><span class="section-number-3">26.1</span> Processes</h3>
<div class="outline-text-3" id="text-26-1">
<p>
Instead of bash, you can run any other program as the main one. For
example, <code>docker run -ti --rm ubuntu top</code>.  This will run <code>top</code>,
and list all processes <code>top</code> can see. Not many, really.
</p>
</div>
</div>

<div id="outline-container-org57a83c4" class="outline-3">
<h3 id="org57a83c4"><span class="section-number-3">26.2</span> Network</h3>
<div class="outline-text-3" id="text-26-2">
<p>
Let's play with netstat. Netstat is not installd by default, so
we'll have to install it each time.
</p>

<div class="org-src-container">
<pre class="src src-bash"><span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">isolated</span>
docker run --rm -ti ubuntu bash -ci <span style="font-style: italic;">"apt update &amp;&amp; apt install net-tools &amp;&amp; netstat -atunp"</span>
<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">shared network</span>
docker run --net=host --rm -ti ubuntu bash -ci <span style="font-style: italic;">"apt update &amp;&amp; apt install net-tools &amp;&amp; netstat -atunp"</span>
</pre>
</div>
</div>
</div>


<div id="outline-container-orgaec6fa8" class="outline-3">
<h3 id="orgaec6fa8"><span class="section-number-3">26.3</span> filesystem</h3>
<div class="outline-text-3" id="text-26-3">
<p>
You should be able to peek through directories by mounting volumes.
</p>
<div class="org-src-container">
<pre class="src src-bash">docker run --rm -ti -v /tmp:/mything ubuntu ls /mything
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org1d0deb9" class="outline-2">
<h2 id="org1d0deb9"><span class="section-number-2">27</span> Can a container run more than one process?</h2>
<div class="outline-text-2" id="text-27">
<p>
Yes. Let's try something
</p>
<div class="org-src-container">
<pre class="src src-bash">docker run --rm -ti ubuntu bash
<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">inside the container's shell</span>
top
</pre>
</div>
<p>
There you see 2 processes, bash and top.
</p>
</div>
</div>

<div id="outline-container-org5f3bed6" class="outline-2">
<h2 id="org5f3bed6"><span class="section-number-2">28</span> Using cat from ubuntu container</h2>
<div class="outline-text-2" id="text-28">
<div class="org-src-container">
<pre class="src src-bash">docker run --rm ubuntu cat /etc/lsb-release
</pre>
</div>
</div>
</div>

<div id="outline-container-org94f982e" class="outline-2">
<h2 id="org94f982e"><span class="section-number-2">29</span> mount a file and cat it from inside</h2>
<div class="outline-text-2" id="text-29">
<div class="org-src-container">
<pre class="src src-bash">docker run --rm -v /etc/lsb-release:/etc/lsb-release ubuntu cat /etc/lsb-release
</pre>
</div>
</div>
</div>

<div id="outline-container-org6bfabd7" class="outline-2">
<h2 id="org6bfabd7"><span class="section-number-2">30</span> Playing with scratch image</h2>
<div class="outline-text-2" id="text-30">
<p>
We'll create a filesystem starting from the absolute
minimum. <code>scratch</code>, looks like an empty filesystem.
</p>

<p>
to do the bare minimum explorations possible, we'll get a busybox
from our host and add it to the image.
</p>

<p>
<code>cp /usr/bin/busybox ./busybox</code>
</p>

<div class="org-src-container">
<pre class="src src-Dockerfile">FROM scratch
COPY ./busybox /usr/bin/busybox
COPY ./busybox /bin/sh
CMD ["/usr/bin/busybox", "pwd"]
</pre>
</div>

<p>
After that, <code>docker build --tag bare-min .</code> to build the image, and
then you can start playing with <code>docker run --rm -ti bare-min</code>
</p>

<p>
If you try other command, like <code>docker run --rm -ti bare-min ls</code>,
docker will complain that "ls" executable is not in $PATH. Here we
see that if we override the command from the shell, CMD is replaced
by what we entered. The way to fix it is to enter the full command, so
 <code>docker run --rm -ti bare-min /usr/bin/busybox ls</code> will work.
</p>
</div>
</div>

<div id="outline-container-org9e42379" class="outline-2">
<h2 id="org9e42379"><span class="section-number-2">31</span> Entrypoint</h2>
<div class="outline-text-2" id="text-31">
<p>
A way to lock the main program that runs, but let users modify the
arguments to this, is to use <code>ENTRYPOINT</code>
</p>
</div>
</div>

<div id="outline-container-org587e44e" class="outline-2">
<h2 id="org587e44e"><span class="section-number-2">32</span> Network</h2>
<div class="outline-text-2" id="text-32">
<p>
Footgun Alert:
</p>
<ul class="org-ul">
<li>If you create a docker network via <code>docker network create foo</code>, the name stays exactly <code>foo</code></li>
<li>In a docker compose, the network is named after the project, so if
the structure is like: <code>myproject/docker-compose.yml</code>, and you
<code>docker-compose up</code> and then <code>docker network ls</code>, you'll see a
<code>myproject_default</code> network.</li>
<li><p>
You can name networks in docker-compose:
</p>
<div class="org-src-container">
<pre class="src src-yml">version: '3.5'
services:
  httpbin:
    # this should basically match docker_reverse_proxy.tf
    image: kennethreitz/httpbin
    ports:
      - 8888:80
    networks:
      my_net:
networks:
  my_net:
</pre>
</div>
<p>
Run <code>docker network ls</code> and you'll see that the network is named&#x2026;. <code>myproject_my_net</code>.
</p></li>
<li><p>
In order to give it an absolute name, you can add a "name" to the network.
</p>
<div class="org-src-container">
<pre class="src src-yml">version: '3.5'
services:
  httpbin:
    # this should basically match docker_reverse_proxy.tf
    image: kennethreitz/httpbin
    ports:
      - 8888:80
    networks:
      my_net:
networks:
  my_net:
    name: my_net
</pre>
</div>
<p>
Now <code>docker network ls</code> will tell us that the network is called
<code>my_net</code>. For real :+1:
</p></li>
</ul>
</div>
</div>
<div id="outline-container-org2806fc4" class="outline-2">
<h2 id="org2806fc4"><span class="section-number-2">33</span> Deploy SPA Frontend and Backend</h2>
<div class="outline-text-2" id="text-33">
<p>
In an SPA that makes calls to the backend, the isolation that we
would love in a docker-compose falls appart, because the external
world has to have access to both frontend AND the API backend.
</p>

<p>
docker-compose can publish random free ports, but in this case, the
frontend has to know beforehand what is the port number that backend
is gonna use. That means that for the practical perspective, we have
to publish "8888" in a fixed place. That means that we'll have a
harder time running multiple instances of the stack (ports will
collide unless you play around with passing env_vars with random
ports to publish in the backend AND frontend).
</p>

<div class="org-src-container">
<pre class="src src-text">        +----------------------------------+
        |     Browser                      |
        |   http://localhost:3000          |
        |   js:ajax(http://localhost:8888) |
        |                                  |
        +----------------------------------+
            ^                  ^
            | 3000             | 8888
            |                  |
+-----------+------------------+---------+
|           |           +------+------+  |
| +---------+-------+   |             |  |
| |                 |   | backend     |  |
| |  frontend       |   |             |  |
| |                 |   |             |  |
| |                 |   |             |  |
| |                 |   +-------------+  |
| +-----------------+                    |
|                                        |
|                       +-------------+  |
|                       |             |  |
|                       |  db         |  |
|                       |             |  |
|                       |             |  |
|                       |             |  |
|                       +-------------+  |
|                                        |
|                                        |
+----------------------------------------+
</pre>
</div>
</div>
</div>

<div id="outline-container-org70a17f3" class="outline-2">
<h2 id="org70a17f3"><span class="section-number-2">34</span> container names in a docker-compose</h2>
<div class="outline-text-2" id="text-34">
<p>
A very similar situation to the network one happens with containers
themselves.  That previous service <code>httpbin</code> results in a container
named <code>myproject_httpbin_1</code>. You can fix the name of the container with
<code>container_name: httpbin1</code>. That way you can have global names.
</p>
</div>
</div>

<div id="outline-container-org0d93cbc" class="outline-2">
<h2 id="org0d93cbc"><span class="section-number-2">35</span> Traefik and whole whole shebang</h2>
<div class="outline-text-2" id="text-35">
<p>
So, Traefik is this reverse proxy that is able to manage your
containers in a fairly automatic way.
</p>

<p>
For every container in a docker network that you manage with
traefik, traefik will check the container's labels, and check for
traefik labels that are used for configuring the routes. It's kinda
distributed in the sense that you don't go poke traefik app to
configure it, but it detects when containers are upped and checks by
itself.
</p>

<p>
It also has some default rules, so you can, for example, easily
match the host header to redirect to the container_name.
</p>

<p>
But, how are the container names matched? is it the <code>foo</code>, or
<code>myproject_foo</code>? or <code>myproject_foo_1</code>?
</p>

<p>
It turns out it's smart enough to figure out what you mean.
</p>

<div class="org-src-container">
<pre class="src src-yml">version: '3.5'
services:
  traefik:
    image: traefik:v2.0
    ports:
      - "8888:80"
      - "8080:8080"
    command:
      # https://doc.traefik.io/traefik/v2.0/providers/docker/#defaultrule
      # - --providers.docker.defaultRule=Host(`{{ normalize .Name }}`
      - --api.insecure=true
      - --providers.docker=true
      # - --entrypoints.web.address=:80
      # - --providers.docker.network="my_net",
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
    networks:
      hosting:

  httpbin1:
    image: kennethreitz/httpbin
    # container_name: httpbin2
    networks:
      hosting:
    labels:
      - traefik.enable=true
      - traefik.http.routers.httpbin1.rule=Host(`httpbin1`)
      # - traefik.http.routers.httpbin1.entrypoints=web

networks:
  hosting:
    name: my_net

</pre>
</div>

<p>
with this, and <code>docker-compose up</code>, <code>http :8888/status/202
  Host:httpbin1</code> you can start trying things:
</p>

<p>
If you use a <code>container_name</code>, the Host will try to match it
exactly. If there is no <code>container_name</code>, traeffik still recognizes
Host with just the service name (<code>httpbin1</code> in this case). If you
use <code>myproject_httpbin_1</code>, it WON'T work, so it's DWIM, but it has
its own warts.
</p>

<p>
<a href="https://doc.traefik.io/traefik/user-guides/docker-compose/basic-example/">https://doc.traefik.io/traefik/user-guides/docker-compose/basic-example/</a>
<a href="https://doc.traefik.io/traefik/v2.0/providers/docker/#defaultrule">https://doc.traefik.io/traefik/v2.0/providers/docker/#defaultrule</a>
</p>
</div>
</div>

<div id="outline-container-orgb05a1f8" class="outline-2">
<h2 id="orgb05a1f8"><span class="section-number-2">36</span> can I join?</h2>
<div class="outline-text-2" id="text-36">
<p>
New containers can join the network, and will be playing the game
without having been started on the same docker-compose.
</p>
<ul class="org-ul">
<li><code>docker run --rm --net my_net --name httpbin2 --hostname httpbin2 kennethreitz/httpbin</code>,</li>
<li><code>http :8888/status/202 Host:httpbin2</code></li>
</ul>
</div>
</div>
<div id="outline-container-orga5e62e7" class="outline-2">
<h2 id="orga5e62e7"><span class="section-number-2">37</span> http_proxy, dns, and networks</h2>
<div class="outline-text-2" id="text-37">
<p>
<a href="./projects/network_proxy">./projects/network_proxy</a> contains a testing project that has:
</p>
<ul class="org-ul">
<li>coredns with a fixed ip</li>
<li>httpbin</li>
<li>ubuntu (we'll use it as our shell)</li>
<li>tinyproxy. Lives in the same network</li>
<li><p>
tinyproxy_host lives in the host namespace, so it's accessible
from localhost:8888 from the host, or host.docker.internal from
the other containers.
</p>

<p>
We can start testing things around, by doing <code>docker-compose up</code>,
and on another shell, <code>docker-compose exec main bash</code>. you can run
<code>./script.sh</code> once inside
</p></li>
</ul>
</div>
</div>
<div id="outline-container-orgd5e060b" class="outline-2">
<h2 id="orgd5e060b"><span class="section-number-2">38</span> Dok</h2>
</div>
<div id="outline-container-org35fff32" class="outline-2">
<h2 id="org35fff32"><span class="section-number-2">39</span> gojira</h2>
</div>
<div id="outline-container-org4969abb" class="outline-2">
<h2 id="org4969abb"><span class="section-number-2">40</span> ryu</h2>
</div>
<div id="outline-container-orgdf7739d" class="outline-2">
<h2 id="orgdf7739d"><span class="section-number-2">41</span> mba</h2>
</div>
<div id="outline-container-org0733561" class="outline-2">
<h2 id="org0733561"><span class="section-number-2">42</span> hma</h2>
<div class="outline-text-2" id="text-42">
<p>
So far, the most minimalistic approach.
</p>

<p>
The goal for this project is to have a dev environment for our devs,
with as little code besides the docker-compose.yml file. There are a
few basic traits:
</p>

<ul class="org-ul">
<li>Support for local non-commited customizations. The 3 files involved
are <code>hma.yml</code> <code>hma.mac.yml</code> <code>hma.override.yml</code>. First one is the
main docker-compose file, the <code>.mac.</code> has mac-only modifications,
and <code>hma.override.yml</code> is a local non-commited file that will be
merged on top of the other two.</li>

<li><p>
Augment docker-compose, but keep docker-compose knowledge relevant
and useful.
</p>

<p>
hma uses docker-compose under the hood, and proxies all commands
to docker-compose. It adds the command <code>do</code>, that tries to be
smart about the thing to execute, but all old docker-compose
knowledge is directly applicable here.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>hma up</code></td>
<td class="org-left"><code>docker-compose -f hma.yml -f hma.mac.yml -f hma.override.yml up</code></td>
</tr>

<tr>
<td class="org-left"><code>hma exec ...</code></td>
<td class="org-left"><code>docker-compose -f hma.yml -f hma.mac.yml -f hma.override.yml exec ...</code></td>
</tr>

<tr>
<td class="org-left"><code>hma do</code></td>
<td class="org-left"><code>docker-compose -f hma.yml -f hma.mac.yml -f hma.override.yml exec &lt;main_service&gt; $HMA_CLI</code></td>
</tr>

<tr>
<td class="org-left"><code>hma do db</code></td>
<td class="org-left"><code>docker-compose -f hma.yml -f hma.mac.yml -f hma.override.yml exec db $HMA_CLI</code></td>
</tr>

<tr>
<td class="org-left"><code>hma do db bash</code></td>
<td class="org-left"><code>docker-compose -f hma.yml -f hma.mac.yml -f hma.override.yml exec db bash</code></td>
</tr>
</tbody>
</table></li>

<li>Sane defaults. The &lt;main_service&gt; is guessed by the name of the directory</li>
</ul>


<p>
Key points (tricks) of this approach:
</p>
</div>

<div id="outline-container-org834e5fe" class="outline-3">
<h3 id="org834e5fe"><span class="section-number-3">42.1</span> Mount every container's <i>root to ~</i>.hma/.hma-home/</h3>
<div class="outline-text-3" id="text-42-1">
<p>
We'll mount every services' /root directory to a common directory
in our host machine.
</p>

<p>
This way, all your hma containers will have a persistent $HOME,
meaning that you'll get persistent history, and a fully
customizable environment. Try modifying ~/.hma/.hma-home/.bashrc to
add a new alias, or add a script to <code>~/.hma/.hma-home/bin/</code> (and
add /root/bin to the $PATH in <code>.bashrc</code>).
</p>

<p>
An extra benefit is that all containers share this space at the
same time, so you can copy files among containers and the host
without needing to remember <code>docker cp</code>. It's just like a shared
drive.
</p>

<div class="org-src-container">
<pre class="src src-yaml">volumes:
  - $HOME/.hma/.hma-home:/root:rw
</pre>
</div>
</div>
</div>
<div id="outline-container-org850a535" class="outline-3">
<h3 id="org850a535"><span class="section-number-3">42.2</span> Customize the main app's service</h3>
<div class="outline-text-3" id="text-42-2">
<p>
The main container needs a few modifications. Change the command
and/or entrypoint to a waiting loop like <code>tail -f /dev/null</code>.
</p>

<p>
This way we keep the container alive and we can start our app
manually from within a <code>hma do</code> , which will be an equivalent of
<code>docker-compose exec $HMA_CLI</code>.
</p>

<p>
We should add the environment variable <code>HMA_CLI</code>, pointing to
some meaninful entrypoint for our dev container.
</p>

<p>
Build a developer friendly container to run the app.  This
container can come FROM a microsoft devcontainer, or you can build
your own. It should be dev-friendly to do some file navigation and
basic development in.
</p>

<p>
The volumes to mount are the main one for the app code (where we'll
overwrite the <code>working_dir</code> to), aws credentials, and of course,
the trick to mount the $HOME dir of the user to our "portal"
directory in our host.
</p>

<div class="org-src-container">
<pre class="src src-yaml">services:
  #....
  harbormaster:
    command: tail -f /dev/null
    build:
      context: $PWD/.devcontainer
      dockerfile: Dockerfile
    volumes:
      - $HOME/.aws/credentials:/root/.aws/credentials:rw
      - $PWD:/app/:rw
      - $HOME/.hma/.hma-home:/root:rw
    working_dir: /app
    environment:
      HMA_CLI: bash
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc5cce7c" class="outline-3">
<h3 id="orgc5cce7c"><span class="section-number-3">42.3</span> Dockerfile</h3>
<div class="outline-text-3" id="text-42-3">
<p>
To prepare your main container, ($PWD/.devcontainer/Dockerfile in
the example above), you should leave space for extension on the
<code>.override.yml</code> file. Here's an example:
</p>

<div class="org-src-container">
<pre class="src src-Dockerfile">FROM mcr.microsoft.com/vscode/devcontainers/java:11

ARG EXTRA_DEPS
RUN apt-get update &amp;&amp; apt-get -y install postgresql-client-12 $EXTRA_DEPS
</pre>
</div>

<p>
With this trick, the final user will be able to install custom
packages by editing the <code>hma.override.yml</code>
</p>

<div class="org-src-container">
<pre class="src src-yaml">harbormaster:
  build:
    args:
      EXTRA_DEPS: nvim iputils-ping httpie
</pre>
</div>
</div>
</div>

<div id="outline-container-org337c842" class="outline-3">
<h3 id="org337c842"><span class="section-number-3">42.4</span> Development</h3>
<div class="outline-text-3" id="text-42-4">
<p>
Since we mount the app directory from the host to the container,
development can keep happening on the host, using your favourite
editor.
</p>

<p>
In case of clojure there are a few tunnings more to do:
</p>
<ul class="org-ul">
<li>Expose a port from the container to the host</li>
<li>Configure lein/deps.edn to use that port for the repl.</li>
<li><p>
<code>go-to-definition</code> will break using this approach, because when
your editor (emacs in my case) will ask for a function location
through cider, it will get a path and location according to the
machinery inside the container, that most likely won't match your
external path.
</p>

<div class="org-src-container">
<pre class="src src-yaml">environment:
  LEIN_REPL_PORT: 7888
  LEIN_REPL_HOST: "0.0.0.0"
expose:
  - '7888'
ports:
  - '7888:7888'
</pre>
</div>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="font-weight: bold;">setq</span> cider-path-translations '((<span style="font-style: italic;">"/app/harbormaster/source"</span> . <span style="font-style: italic;">"~/workspace/harbormaster"</span>)
                                (<span style="font-style: italic;">"/app/metabase/source"</span> . <span style="font-style: italic;">"~/workspace/metabase"</span>)
                                (<span style="font-style: italic;">"/root/.m2/"</span> . <span style="font-style: italic;">"~/.hma/.hma-home/.m2/"</span>)))
</pre>
</div></li>
</ul>
</div>
</div>

<div id="outline-container-org6a507de" class="outline-3">
<h3 id="org6a507de"><span class="section-number-3">42.5</span> Code</h3>
<div class="outline-text-3" id="text-42-5">
<div class="org-src-container">
<pre class="src src-bash"><span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">!/usr/bin/</span><span style="font-weight: bold;">env</span><span style="font-weight: bold; font-style: italic;"> bash</span>
<span style="font-weight: bold;">die</span>()  { <span style="font-weight: bold;">echo</span> <span style="font-style: italic;">"$*"</span> ; <span style="font-weight: bold;">exit</span> 1; }
<span style="font-weight: bold;">mkcd</span>() { mkdir -p <span style="font-style: italic;">"$1"</span>; <span style="font-weight: bold;">cd</span> <span style="font-style: italic;">"$1"</span>; }

<span style="font-weight: bold;">pg-create-dbs-file</span>() {
  cat &lt;&lt;<span style="font-style: italic;">'EOF'</span>
<span style="font-weight: bold;">#!/bin/bash</span>

<span style="font-weight: bold;">pg_conf_file=/var/lib/postgresql/data/postgresql.conf</span>

<span style="font-weight: bold;">echo "\</span>
<span style="font-weight: bold;">log_statement = 'all'</span>
<span style="font-weight: bold;">log_disconnections = off</span>
<span style="font-weight: bold;">log_duration = on</span>
<span style="font-weight: bold;">log_min_duration_statement = -1</span>
<span style="font-weight: bold;">shared_preload_libraries = 'pg_stat_statements'</span>
<span style="font-weight: bold;">track_activity_query_size = 2048</span>
<span style="font-weight: bold;">pg_stat_statements.track = all</span>
<span style="font-weight: bold;">pg_stat_statements.max = 10000</span>
<span style="font-weight: bold;">" &gt;&gt;$pg_conf_file</span>

<span style="font-weight: bold;">for database in $(echo $POSTGRES_MULTIPLE_DATABASES | tr ',' ' '); do</span>
<span style="font-weight: bold;">  echo "Creating database $database"</span>
<span style="font-weight: bold;">  psql -U $POSTGRES_USER &lt;&lt;-EOSQL</span>
<span style="font-weight: bold;">    CREATE DATABASE $database;</span>
<span style="font-weight: bold;">    GRANT ALL PRIVILEGES ON DATABASE $database TO $POSTGRES_USER;</span>
<span style="font-weight: bold;">    CREATE EXTENSION IF NOT EXISTS pg_stat_statements;</span>
<span style="font-weight: bold;">EOSQL</span>

<span style="font-weight: bold;">  psql -v ON_ERROR_STOP=1 --username "$POSTGRES_USER" -d "$database" &lt;&lt;-EOSQL</span>
<span style="font-weight: bold;">    CREATE EXTENSION IF NOT EXISTS pg_stat_statements;</span>
<span style="font-weight: bold;">EOSQL</span>
<span style="font-weight: bold;">done</span>
<span style="font-weight: bold;">EOF</span>
}

<span style="font-weight: bold;">hma-setup</span>() {
  [ -f $<span style="font-weight: bold; font-style: italic;">1</span> ] &amp;&amp; grep -siq <span style="font-style: italic;">'HMA_CLI'</span> $<span style="font-weight: bold; font-style: italic;">1</span> || die <span style="font-style: italic;">"Not an hma-compatible repo."</span>
  [ -d $<span style="font-weight: bold; font-style: italic;">HOME</span>/.mba/.mba-home/ ] || mkdir -p $<span style="font-weight: bold; font-style: italic;">HOME</span>/.mba/.mba-home
  [ -d $<span style="font-weight: bold; font-style: italic;">HOME</span>/.mba/resources/postgres/docker-entrypoint-initdb.d/ ] || (
    mkcd $<span style="font-weight: bold; font-style: italic;">HOME</span>/.mba/resources/postgres/docker-entrypoint-initdb.d/ &amp;&amp;
      pg-create-dbs-file &gt; 00-create-pg-db.sh &amp;&amp; chmod +x 00-create-pg-db.sh
  )
}
<span style="font-weight: bold;">hma-exec</span> () {
  local <span style="font-weight: bold; font-style: italic;">where</span>=${<span style="font-weight: bold; font-style: italic;">1</span>:-$(basename $<span style="font-weight: bold; font-style: italic;">PWD</span>)}
  <span style="font-weight: bold;">shift</span>
  local <span style="font-weight: bold; font-style: italic;">cmd</span>=${<span style="font-weight: bold; font-style: italic;">@</span>:-<span style="font-style: italic;">'$HMA_CLI'</span>}
  hma exec <span style="font-style: italic;">"$where"</span> sh -lic <span style="font-style: italic;">"$cmd"</span>
}

<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">hma up [maildev db]</span>
<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">hma down</span>
<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">hma do [service] [$HM_CLI]</span>
<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">hma do db</span>
<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">hma do db bash</span>
<span style="font-weight: bold;">hma</span>() {
  <span style="font-weight: bold; font-style: italic;">fname</span>=<span style="font-style: italic;">"hma"</span>
  hma-setup <span style="font-style: italic;">"${fname}.yml"</span>
  <span style="font-weight: bold;">if</span> [[ $<span style="font-weight: bold; font-style: italic;">1</span> == <span style="font-style: italic;">"do"</span> ]]; <span style="font-weight: bold;">then</span>
    <span style="font-weight: bold;">shift</span>
    hma-exec <span style="font-style: italic;">"$@"</span>
  <span style="font-weight: bold;">else</span>
    local <span style="font-weight: bold; font-style: italic;">files</span>=(<span style="font-style: italic;">"-f ${fname}.yml"</span>)
    [[ <span style="font-style: italic;">"$OSTYPE"</span> == <span style="font-style: italic;">"darwin"</span>* ]] &amp;&amp; [ -f <span style="font-style: italic;">"./${fname}.mac.yml"</span> ] &amp;&amp; files+=(<span style="font-style: italic;">"-f ./${fname}.mac.yml"</span>)
    [ -f <span style="font-style: italic;">"./${fname}.override.yml"</span> ] &amp;&amp; files+=(<span style="font-style: italic;">"-f ./${fname}.override.yml"</span>)
    docker-compose ${<span style="font-weight: bold; font-style: italic;">files</span>[*]} <span style="font-style: italic;">"$@"</span>
  <span style="font-weight: bold;">fi</span>
}

hma <span style="font-style: italic;">"$@"</span>

</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org0d6176d" class="outline-2">
<h2 id="org0d6176d"><span class="section-number-2">43</span> Docker as a tool to help you hack on development</h2>
<div class="outline-text-2" id="text-43">
<ul class="org-ul">
<li><a href="https://fly.io/blog/docker-without-docker/">https://fly.io/blog/docker-without-docker/</a>
<ul class="org-ul">
<li><a href="https://gist.github.com/tqbf/10006fae0b81d7c7c93513890ff0cf08">https://gist.github.com/tqbf/10006fae0b81d7c7c93513890ff0cf08</a></li>
</ul></li>
<li><a href="https://vsupalov.com/rebuilding-docker-image-development/">https://vsupalov.com/rebuilding-docker-image-development/</a></li>
<li><a href="https://news.ycombinator.com/item?id=27343933">https://news.ycombinator.com/item?id=27343933</a></li>
<li><a href="https://blog.gougousis.net/file-permissions-the-painful-side-of-docker/">https://blog.gougousis.net/file-permissions-the-painful-side-of-docker/</a></li>
</ul>
</div>
<div id="outline-container-orgac76fc8" class="outline-3">
<h3 id="orgac76fc8"><span class="section-number-3">43.1</span> network</h3>
<div class="outline-text-3" id="text-43-1">
<ul class="org-ul">
<li><a href="http://flaviotoffalini.info/posts/2019/07/docker-network/">http://flaviotoffalini.info/posts/2019/07/docker-network/</a></li>
<li><a href="https://www.cb-net.co.uk/devops/docker-container-network-isolation/">https://www.cb-net.co.uk/devops/docker-container-network-isolation/</a></li>
<li><a href="https://iximiuz.com/en/posts/container-networking-is-simple/">https://iximiuz.com/en/posts/container-networking-is-simple/</a></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgbf7de52" class="outline-2">
<h2 id="orgbf7de52"><span class="section-number-2">44</span> dev</h2>
<div class="outline-text-2" id="text-44">
<ul class="org-ul">
<li><a href="https://earthly.dev/">https://earthly.dev/</a></li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Raimon Grau</p>
<p class="creator"><a href="https://www.gnu.org/software/emacs/">Emacs</a> 26.1 (<a href="https://orgmode.org">Org</a> mode 9.1.9)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
